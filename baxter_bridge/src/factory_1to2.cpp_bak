#include <baxter_bridge/bridge_1to2.h>
#include <baxter_bridge/factory.h>

// messages
#include <sensor_msgs/Range.h>
#include <sensor_msgs/Image.h>
#include <sensor_msgs/JointState.h>


#include <sensor_msgs/msg/range.hpp>
#include <sensor_msgs/msg/image.hpp>
#include <sensor_msgs/msg/joint_state.hpp>

namespace baxter_bridge
{

//using namespace baxter_core_msgs;

// message forwards
inline std_msgs::msg::Header forwardROS2(const std_msgs::Header &header, Node2* node2)
{
  return std_msgs::msg::Header()
      .set__frame_id(header.frame_id)
      .set__stamp(node2->get_clock()->now());
}

inline sensor_msgs::msg::Image forwardROS2(const sensor_msgs::Image &im, Node2* node2)
{
  return sensor_msgs::msg::Image()
      .set__data(im.data)
      .set__step(im.step)
      .set__width(im.width)
      .set__header(forwardROS2(im.header, node2))
      .set__height(im.height)
      .set__encoding(im.encoding)
      .set__is_bigendian(im.is_bigendian);
}

inline sensor_msgs::msg::Range forwardROS2(const sensor_msgs::Range &range, Node2* node2)
{
  return sensor_msgs::msg::Range()
      .set__range(range.range)
      .set__header(forwardROS2(range.header, node2))
      .set__max_range(range.max_range)
      .set__min_range(range.min_range)
      .set__field_of_view(range.field_of_view)
      .set__radiation_type(range.radiation_type);
}

inline sensor_msgs::msg::JointState forwardROS2(const sensor_msgs::JointState &js, Node2* node2)
{
  return sensor_msgs::msg::JointState()
      .set__name(js.name)
      .set__effort(js.effort)
      .set__position(js.position)
      .set__velocity(js.velocity)
      .set__header(forwardROS2(js.header, node2));
}



// factory
void Factory::createBridge_1to2(const std::string &topic, const std::string &msg)
{
  if(msg == "sensor_msgs/JointState")
  {
    bridges.push_back(std::make_unique<Bridge_1to2<sensor_msgs::JointState, sensor_msgs::msg::JointState>>
                      (topic));
  }
}




}
